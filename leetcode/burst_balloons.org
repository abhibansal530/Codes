#+TITLE: Burst Balloons

* Problem
You are given =n= balloons, indexed from =0= to =n - 1=. Each balloon is painted with a number on it
represented by an array =nums=. You are asked to burst all the balloons.

If you burst the =ith= balloon, you will get =nums[i - 1] * nums[i] * nums[i + 1]= coins. If =i - 1= or
=i + 1= goes out of bounds of the array, then treat it as if there is a balloon with a =1= painted on it.

Return the maximum coins you can collect by bursting the balloons wisely.
* Idea
Let's suppose we burst =kth= balloon first in our soln. then we'll get coins corresponding to that + max coins
for remaining balloons. Now tricky part here is how to represent the remaining problem (or subproblem). One way
can be to create a new array with remaining balloons and solve that. But obviously that'll be very inefficient.

Insight here is to work *backwards*. Instead of starting from the first balloon which we need to burst in our
optimal soln., start with the last balloon. Let's say we burst =kth= balloon in the end then it'll comprise of
three steps :

1. Burst balloons[0..k - 1].
2. Burst balloons[k + 1..n - 1].
3. Burst balloons[k].

*Note*: Step 1. and 2. can be interchanged here.

Now we have got well defined subproblems to solve.

So final soln. is to build DP[l][r] which represents optimal soln. for bursting balloons[l..r]. To fill this state
we iterate over each =k= s.t. =l= <= =k= <= =r= and treat that as the last balloon which we'll burst.
* Solution
#+BEGIN_SRC cpp
class Solution {
public:
    int maxCoins(vector<int>& nums) {
        int n = nums.size();
        vector<vector<int>> dp(n, vector<int>(n, 0));

        for (int l = 1; l <= n; ++l) {
            for (int i = 0, j = i + l - 1; i < n && j < n; ++i, ++j) {
                for (int last = i; last <= j; ++last) {
                    int lft = last > i ? dp[i][last - 1] : 0;
                    int rt = last < j ? dp[last + 1][j] : 0;
                    int cost = nums[last] * (i ? nums[i - 1] : 1) *
                        (j + 1 < n ? nums[j + 1] : 1);

                    dp[i][j] = max(dp[i][j], cost + lft + rt);
                }
            }
        }

        return dp[0][n - 1];
    }
};
#+END_SRC
