#+TITLE: Longest Consecutive Sequence

* Problem
Given an unsorted array of integers =nums=, return the length of the longest consecutive elements sequence.

#+BEGIN_EXAMPLE
*Input:* nums = [100,4,200,1,3,2]
*Output:* 4
*Explanation:* The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
#+END_EXAMPLE
* Approach 1
Sort the array and do one pass over it to find the longest consecutive sequence.
* Approach 2
We can use DSU to efficiently merge disjoint intervals.

#+BEGIN_SRC cpp
class Solution {
    class UnionFind {
        unordered_map<int, int> parent_, size_;

        public:
        bool Make(int x) {
            if (parent_.count(x)) return false;
            parent_[x] = x, size_[x] = 1;
            return true;
        }

        bool Find(int x, int* root) {
            auto it = parent_.find(x);
            if (it == parent_.end()) return false;

            int par = it->second;
            if (par == x) {
                *root = x;
                return true;
            }

            Find(par, root);
            parent_[x] = *root;
            return true;
        }

        void Merge(int x, int y) {
            int px, py;
            Find(x, &px);
            Find(y, &py);

            if (px == py) return;
            if (size_[px] > size_[py]) {
                parent_[py] = px;
                size_[px] += size_[py];
                return;
            }

            parent_[px] = py;
            size_[py] += size_[px];
        }

        int SetSize(int x) {
            int root;
            if (Find(x, &root)) {
                return size_[root];
            }
            return 0;
        }
    };

public:
    int longestConsecutive(vector<int>& nums) {
        int ans = 0;
        UnionFind uf;
        for (int x : nums) {
            if (!uf.Make(x)) continue;
            int root;
            if (uf.Find(x - 1, &root)) {
                uf.Merge(x, root);
            }

            if (uf.Find(x + 1, &root)) {
                uf.Merge(x, root);
            }

            ans = max(ans, uf.SetSize(x));
        }
        return ans;
    }
};
#+END_SRC
* Approach 3
Instead of maintaining a DSU, just start from the lowest end of any possible chain. Specifically if
we pick an element =x= to be our candidate starting point, but we know that =x - 1= also exists in our
array, then skip =x=. Otherwise try to extend the sequence starting from =x=.

#+BEGIN_SRC cpp
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> nums_set;
        for (int x : nums) {
            nums_set.insert(x);
        }

        int ans = 0;
        for (int start : nums_set) {
            if (nums_set.count(start - 1)) {
                // We'll process this by a prev start.
                continue;
            }

            // Find longest chain with current start.
            int len = 1, next = start + 1;
            while (nums_set.count(next)) {
                ++len;
                ++next;
            }

            ans = max(ans, len);
        }

        return ans;
    }
};
#+END_SRC
