#+TITLE: Restore IP Addresses

* Problem
Given a string =s= containing only digits, return all possible valid IP addresses that can be obtained from =s=. You can return them in any order.

A *valid IP address* consists of exactly four integers, each integer is between =0= and =255=, separated by single dots and cannot have leading zeros.
For example, "0.1.2.201" and "192.168.1.1" are *valid* IP addresses and "0.011.255.245", "192.168.1.312" and "192.168@1.1" are *invalid* IP addresses.
* Solution
Can be done recursively.
* Code
#+BEGIN_SRC cpp
class Solution {
    int StoI (const string& s) {
        int m = 1, len = s.size(), ans = 0;
        for (int i = len - 1; i >= 0; --i, m *= 10) {
            ans += (s[i] - '0') * m;
        }
        return ans;
    }

    bool isValid(const string& part) {
        if (part.empty() || part.size() > 3) {
            return false;
        }

        if (part[0] == '0') {
            return part.size() == 1;
        }
        return StoI(part) <= 255;
    }

    vector<string> solveRec(const string& s, int start, int num_parts) {
        int len = s.size();
        vector<string> ips;
        if (!num_parts) {
            if (start >= len) ips.push_back("");
            return ips;
        }

        if (start >= len) {
            return ips;
        }

        string part;
        for (int i = start; i < len; ++i) {
            part += s[i];
            if (!isValid(part)) {
                break;
            }

            auto nxt_parts = solveRec(s, i + 1, num_parts - 1);
            while (!nxt_parts.empty()) {
                auto& nxt = nxt_parts.back();
                auto combined = part + (nxt.empty() ? "" : ("." + nxt));
                nxt_parts.pop_back();
                ips.push_back(move(combined));
            }
        }

        return ips;
    }

public:
    vector<string> restoreIpAddresses(string s) {
        return solveRec(s, 0, 4);
    }
};
#+END_SRC
